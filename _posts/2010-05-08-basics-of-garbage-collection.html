---
layout: post
title: Basics of Garbage Collection
date: 2010-05-08 10:41:00.000000000 +08:00
type: post
published: true
status: publish
categories:
- C#
tags: []
meta:
  blogger_author: Taher Dhilawala
  blogger_blog: tdtechdiary.blogspot.com
  blogger_d55bd4009d1dee1a46eef7a078bee8f9_permalink: '1989324731157531347'
  _edit_last: '14307922'
  _wpas_skip_fb: '1'
author:
  login: tdtechdiary
  email: salaam_taher@yahoo.com
  display_name: Taher Dhilawala
  first_name: ''
  last_name: ''
---
<p><span style="font-family:verdana;font-size:85%;">Garbage Collection is an automatic Memory </span><span style="font-family:verdana;font-size:85%;">Management </span><span style="font-family:verdana;font-size:85%;">system in .NET. This article explains how garbage collectors work, then goes on to discuss some of the performance problems that might be encountered in a garbage-collected environment.</span></p>
<p>Lets first have a look at the basic memory model,</p>
<p><span style="font-family:verdana;font-size:85%;"><a href="http://tdtechdiary.files.wordpress.com/2010/05/memorymodel.png"><img src="{{ site.baseurl }}/assets/memorymodel.png?w=300" alt="" border="0" /></a></span><span style="font-family:times new roman;font-size:85%;">The rules for the above model are as follows,<br />
</span></p>
<ul style="font-family:times new roman;" type="disc">
<li><span style="font-size:85%;">All garbage-collectable objects are allocated from one contiguous range of address space. </span></li>
<li><span style="font-size:85%;">The heap is divided into <em>generations</em> (</span><span style="font-size:85%;">more on this later) so that it is possible to eliminate most of the garbage by looking at only a small fraction of the heap. </span></li>
<li><span style="font-size:85%;">Objects within a generation are all roughly the same age.</span></li>
<li><span style="font-size:85%;">Higher-numbered generations indicate areas of the heap with older objects—those objects are much more likely to be stable.</span></li>
<li><span style="font-size:85%;">The oldest objects are at the lowest addresses, while new objects are created at increasing addresses. (Addresses are increasing going down in Figure 1 above.)</span></li>
<li><span style="font-size:85%;">The allocation pointer for new objects m</span><span style="font-size:85%;">arks the boundary between the used (allocated) and unused (free) areas of memory.</span></li>
<li><span style="font-size:85%;">Periodically the heap is compacted by removing dead objects and sliding the live objects up toward the low-address end of the heap. This expands the unused area at the bottom of the diagram in which new objects are created. </span></li>
<li><span style="font-size:85%;">The order of objects in memory remains the order in which they were created, for good locality. </span></li>
<li><span style="font-size:85%;">There are never any gaps between objects in the heap.</span></li>
</ul>
<p><span style="font-family:times new roman;font-size:85%;">There are two types of Garbage Collection</span></p>
<ol style="font-family:verdana;">
<li><span style="font-size:85%;">Full Collection</span></li>
<li><span style="font-size:85%;">Partial Collection</span></li>
</ol>
<p><span style="font-family:verdana;font-size:85%;">The easiest kind of collection to understand is the full garbage collection, so I'll begin by discussing that.</span></p>
<p>&nbsp;</p>
<h3 class="dtH1" style="font-family:verdana;"><span style="font-size:85%;">Full Collection</span></h3>
<p><span style="font-family:verdana;font-size:85%;">In full collection the program execution is stopped and then the system finds all the root objects in the GC Heap (shown in figure above). These roots come in a variety of forms, but are most notably stack and global variables that point into the heap. Starting from the roots, the system visits every object and follow every object pointer</span><span style="font-family:verdana;font-size:85%;"> contained in every visited object marking the objects as it goes along. In this way the collector will find every <em>reachable </em>or<em> live </em>object. The other objects, the <em>unreachable</em> ones, are now <em>condemned</em>.</span></p>
<p><a style="font-family:verdana;" href="http://tdtechdiary.files.wordpress.com/2010/05/rootsintothegcheap.gif"><img title="Courtesy : http://msdn.microsoft.com" src="{{ site.baseurl }}/assets/rootsintothegcheap.gif?w=300" alt="GC Heap" border="0" /></a><span style="font-family:verdana;font-size:85%;">Once the unreachable objects have been identified we want to reclaim that space for later use; the goal of the collector at this point is to slide the <em>live</em> objects up and eliminate the wasted space. With execution stopped, it's safe for the collector to move all those objects, and to fix all the pointers so that everything is properly linked in its new location. The surviving objects are promoted to the next generation number (which is to say the boundaries for the generations are updated) and execution can resume.</span></p>
<p>&nbsp;</p>
<h3 class="dtH1" style="font-family:verdana;"><span style="font-size:85%;">Partial Collection</span></h3>
<p><span style="font-size:85%;">Unfortunately, the full garbage collection is simply too expensive to do every time, so now it's appropriate to discuss how having generations in the collection helps us out.</span></p>
<p style="font-family:verdana;"><span style="font-size:85%;">First let's consider an imaginary case where we are extraordinarily lucky. Let's suppose that there was a recent full collection and the heap is nicely compacted. Program execution resumes and some allocations happen. In fact, lots and lots of allocations happen and after enough allocations the memory management system decides it's time to collect.</span></p>
<p style="font-family:verdana;"><span style="font-size:85%;">Now here's where we get lucky. Suppose that in all of the time we were running since the last collection we didn't write on any of the older objects at all, only newly allocated, <em>generation zero </em>(gen<sub>0</sub>), objects have been written to. If this were to happen we would be in a great situation because we can simplify the garbage collection process massively.</span></p>
<p style="font-family:verdana;"><span style="font-size:85%;">Instead of our usual full collect we can just assume that all of the older objects (gen<sub>1, </sub>gen<sub>2) </sub>are still live—or at least enough of them are alive that it isn't worth looking at those objects. Furthermore, since none of them were written (remember how lucky we are?) there are no pointers from the older objects to the newer objects. So what we can do is look at all the roots like usual, and if any roots point to old objects just ignore those ones. For other roots (those pointing into gen<sub>0</sub>) we proceed as usual, following all the pointers. Whenever we find an internal pointer that goes back into the older objects, we ignore it.</span></p>
<p style="font-family:verdana;"><span style="font-size:85%;">When that process is done we will have visited every live object in gen<sub>0</sub> without having visited any objects from the older generations. The gen<sub>0 </sub>objects can then be condemned as usual and we slide up just that region of memory, leaving the older objects undisturbed.</span></p>
<p style="font-family:verdana;"><span style="font-size:85%;">Now this is really a great situation for us because we know that most of the dead space is likely to be in younger objects where there is a great deal of churn. Many classes create temporary objects for their return values, temporary strings, and assorted other utility classes like enumerators and whatnot. Looking at just gen<sub>0 </sub>gives us an easy way to get back most of the dead space by looking at only very few of the objects. </span></p>
<p style="font-family:verdana;"><span style="font-size:85%;">Unfortunately, we're never lucky enough to use this approach, because at least some older objects are bound to change so that they point to new objects. If that happens it's not sufficient to just ignore them.</span></p>
<p style="font-family:verdana;"><span style="font-size:85%;"><br />
</span></p>
<h3 class="dtH1" style="font-family:verdana;"><span style="font-size:85%;">Making Generations work with Write Barriers</span></h3>
<p><span style="font-size:85%;">To make the algorithm above actually work, we must know which older objects have been modified. To remember the location of the dirty objects, we use a data structure called the <em>card table</em>, and to maintain this data structure the managed code compiler generates so-called <em>write barriers. </em>These two notions are central the success of generation-based garbage collecting.</span></p>
<p><span style="font-size:85%;">The card table can be implemented in a variety of ways, but the easiest way to think of it is as an array of bits. Each bit in the card table represents a range of memory on the heap—let's say 128 bytes. Every time a program writes an object into some address, the write barrier code must compute which 128-byte chunk was written and then set the corresponding bit in the card table.</span></p>
<p><span style="font-size:85%;">With this mechanism in place, we can now revisit the collection algorithm. If we are doing a gen<sub>0 </sub>garbage collection, we can use the algorithm as discussed above, ignoring any pointers to older generations, but once we have done that we must then also find every object pointer in every object that lies on a chunk that was marked as modified in the card table. We must treat those just like roots. If we consider those pointers as well, then we will correctly collect just the gen<sub>0</sub></span> objects.</p>
<p><span style="font-size:85%;">This approach wouldn't help at all if the card table was always full, but in practice comparatively few of the pointers from the older generations actually get modified, so there is a substantial savings from this approach.</span></p>
<div class="blogger-post-footer"></div>
